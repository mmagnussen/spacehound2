/**
 * Copyright (c) 2016 Jens Elkner. All rights reserved.
 * License: CDDL 1.0
 */

'use strict';

const os = require("os");
const fs = require("fs");
const net = require("net");
const path = require("path");
const util = require("util");
const child_process = require("child_process");
const EventEmitter = require("events").EventEmitter;

exports.Runner = Runner;

/**
 * The instance which manages the daemon. Manage means basically starting incl.
 * monitoring the start of the daemon and giving back corresponding information.
 * Stopping depends on a pidfile, the privilege to read/write it and the
 * privilege to send signals to the process with the pid stored in the pidfile. 
 * So stopping is just for convinience and might result in a NOOP if one or
 * more of the mentioned privileges are unavailable. Also for convinience the
 * runner will set the pidfile option automatically, when it gets started on a
 * tty. Otherwise the default is to not use a pidfile and thus will also not be
 * able to stop the daemon by itself. This is the recommended way if service
 * management facilities like SMF or systemd are used to manage the service.
 * @constructor
 * @param {Object}	an object containing key=value pairs honored by the runner.
 * @see setOptions
 */
function Runner(options) {
	if (!(this instanceof Runner)) {
		return new Runner(options);
	}
	// Initialize necessary properties from EventEmitter in this instance
	EventEmitter.call(this);
	Object.defineProperty(this, 'OPTIONS', {
		value: { main:1, name:1, pidfile:1, umask:1, timeout:1, foreground:1,
			execArgv:1, args:1, cwd:1, env:1, stdout:1, stderr:1, uid:1, gid:1,
			detached:1 },
		writeable: false
	});
	Object.defineProperty(this, 'opts', {
		value: {},
		writeable: false,
		enumerable: true
	});
	this.on('daemon', this.defaultListener);
	this.setOptions(options);
}
// Inherit functions from EventEmitter's prototype
util.inherits(Runner, EventEmitter);

/**
 * Convinience fn to set one or more key=value pairs honored by this instance.
 *
 * The following properties are honored:
 *   option   |      type     | decription
 * -----------|---------------|-----------
 * main       | string        | The name of the JS file, which contains the app
 *            |               | to run as daemon. Needs to be in the ${CWD} or
 *            |               | resolvable via node's module lookup algorithm.
 * name       | string        | The short name of the application, which can be
 *            |               | used as title as well. Default: daemon
 * pidfile    | string        | Pidfile to use. Only required, if you wanna use
 *            |               | the runner for stopping it as well. Default:
 *            |               | autogenerated if started on tty, none otherwise.
 * umask      | number        | umask to set for the daemon. Default: inherit
 * timeout    | number        | timeout to use to wait for a feedback of the
 *            |               | app after it has been started (seconds).
 *            |               | Default: 30
 * foreground | boolean       | Don't start the app as daemon but in foreground.
 *            |               | Offen useful for troubleshooting, to see why the
 *            |               | daemon does not start properly. Default: false
 * execArgv   | array         | Same as for ChildProcess.spawn(...), i.e.
 *            |               | options to the node binary itself.
 *            |               | Default: inherit
 * args       | array         | Same as for ChildProcess.spawn(...), i.e.
 *            |               | options and operands for the main app itself.
 *            |               | Default: inherit
 * cwd        | string        | Same as for ChildProcess.spawn(...).
 *            |               | Default: inherit
 * env        | array         | Same as for ChildProcess.spawn(...).
 *            |               | Default: inherit
 * stdout     | string|stream | The stdin parameter for the stdio vector of the
 *            |               | options object for ChildProcess.spawn(...). 
 *            |               | Should be 'ignore' aka /dev/null or a stream,
 *            |               | otherwise the runner may notwork as expected.
 *            |               | Default: 'ignore'
 * stderr     | string|stream | The stdout parameter for the stdio vector of the
 *            |               | options object for ChildProcess.spawn(...). 
 *            |               | Should be 'ignore' aka /dev/null or a stream,
 *            |               | otherwise the runner may notwork as expected.
 *            |               | Default: 'ignore'
 * uid        | number        | The uid the daemon should use. Note that this
 *            |               | requires add. privileges - see Process.setuid().
 *            |               | Default: inherit
 * gid        | number        | The gid the daemon should use. Note that this
 *            |               | requires add. privileges - see Process.setgid().
 *            |               | Default: inherit
 * detached   | boolean       | If true, make the daemon a process leader w/o
 *            |               | a controlling terminal, i.e. call setsid(2).
 *            |               | Otherwise honored on Windows only: makes sure,
 *            |               | that the daemon gets killed with its parent
 *            |               | aka runner. Ignored. Default: !foreground
 *
 * @param {Object}  an object containing the key=value pairs to set. Honored
 *	pairs get copied into the internal store, all others are ignored.
 */
Runner.prototype.setOptions = function(options) {
	if (options===undefined || options==null || typeof options !== 'object') {
		return;
	}
	for (var name in options) {
		if (name in this.OPTIONS) {
			this.opts[name] = options[name];
		}
	}
}

/** Check the given runner's pidfile option. If it has it alread set, do
	nothing unless checkWritable is set. In this case it is also checked,
	whether the pidfile is writable and return false, if not.
	If no pidfile is set and this instance has a tty, a default name will
	be used and set unless it is not writable.
	@return false if the given runner has a pidfile option set and the given
		file is not writable, true otherwise. */
function checkPidfileOption(aRunner, checkWritable) {
	if (!!aRunner.opts.pidfile) {
		if (checkWritable)
			try { fs.appendFileSync(aRunner.opts.pidfile, '\n'); }
			catch (e) { return false; }
	} else if (process.stdout.isTTY) {
		var tmp = path.basename(aRunner.opts.name||aRunner.opts.main)
			.replace(/[^a-zA-Z0-9]/g,'_').toLowerCase();
		tmp = path.join(os.platform() == 'win32' ? os.tmpdir() : '/tmp',
			tmp + '_' + process.geteuid() + '.pid'); 
		if (checkWritable) {
			try {
				fs.appendFileSync(tmp, '\n');
			} catch (e) {
				// ok, doesn't work, so no default pidfile
				console.log('Default pidfile %s will not be used '
					+ '(not writable).', tmp);
				return true;
			}
		}
		aRunner.opts.pidfile = tmp;
	}
	return true;
}

/**
 * Complement unset options and do minimal value checks, i.e. properties which
 * get passed to spawn() are passed as is - spawn() will do the checks ...
 *
 * It gets always called, when the Runner starts the daemon, so there is no
 * need to call it manually. Is is exposed just for convinience, only.
 *
 * @return a possibly empty array of strings, which describe each encountered 
 *		problem.
 */
Runner.prototype.checkOptions = function() {
	var err = [];
	var tmp, num;
	var parseNum = function(n) {
		if (Number.isInteger(n))
			return n;
		var b = n.substr(0,2).toLowerCase();
		return parseInt(n, b == "0x" ? 16 : (b.charAt(0) == '0' ? 8 : 10));
	}

	this.opts.foreground = !!this.opts.foreground;
	if (!this.opts.cwd)
		this.opts.cwd = process.cwd();
    if (!this.opts.main) {
        err.push('Option "main" not set.');
	} else if (!path.isAbsolute(this.opts.main)) {
		tmp = path.normalize(process.cwd() + path.sep + this.opts.main);
		try { fs.accessSync(tmp, fs.R_OK); } catch(e) { tmp = '' };
		if (!tmp) {
			tmp = path.normalize(path.dirname(process.mainModule.filename)
				+ path.sep + this.opts.main);
			try { fs.accessSync(tmp, fs.R_OK); } catch(e) { tmp = '' };
		}
		if (tmp) {
			this.opts.main = tmp;
		} else {
			err.push('App script "'+ this.opts.main + '" not found.')
		}
	} else {
		try {
			fs.accessSync(this.opts.main, fs.R_OK);
		} catch(e) {
			err.push('App script "' + this.opts.main + '" is not readable.');
		}
	}
	tmp = this.opts.execArgv || process.execArgv;
	if (tmp === process.execArgv && process._eval != null) {
		const index = tmp.lastIndexOf(process._eval);
		if (index > 0) {
			// Remove the -e switch to avoid fork bombing ourselves.
			tmp = tmp.slice();
			tmp.splice(index - 1, 2);
			this.opts.execArgv = tmp;
		}
	}
	if (!this.opts.args) {
		// we prefix it with [ process.execArgv, opts.main] when spawning
		this.opts.args = process.argv.slice(2);
	}
	if (!this.opts.env)
		this.opts.env = process.env;
	// we do no checks here. Assume the callee knows, what it does ->
	// let spwan decide
	this.opts.stdio = this.opts.foreground
		? [ 'ignore', 'inherit', 'inherit', 'ipc' ]
		: [ 'ignore', 'ignore', 'ignore', 'ipc' ];
	if (!!this.opts.stdout) {
		this.opts.stdio[1] = this.opts.stdout;
	}
	if (!!this.opts.stderr) {
		this.opts.stdio[2] = this.opts.stderr;
	} else {
		this.opts.stdio[2] = this.opts.stdio[1]
	}
	if (!checkPidfileOption(this, true))
		err.push('Pidfile "' + this.opts.pidfile + '" is not writable.');
    if (!!this.opts.umask) {
		try {
			num = parseNum(this.opts.umask);
			if (num < 0 || num > 511) {
				err.push('The umask "' + this.opts.umask
					+ '" is out of range (0..0777).');
			}
		} catch (e) {
			err.push('Invalid umask "' + this.opts.umask + '".');
		}
	}
    if (!this.opts.timeout) {
		this.opts.timeout = 10;
	} else {
		try {
			num = parseNum(this.opts.timeout); 
			if (num < 0) {
				err.push('The timeout value "' + this.opts.timeout
					+ '" is out of range (negativ).');
			} else if (num == 0) {
				this.opts.timeout = 10;
			}
		} catch(e) {
			err.push('Invalid timeout value "' + this.opts.timeout + '".');
		}
	}
	if (!this.opts.name)
		this.opts.name = 'daemon';
	return err;
};

/**
 * Convinience fn to check, whether the daemon is already running. Depends on
 * pidfile and might not produce the correct answer.
 * @return the pid read on success, 0 otherwise.
 */
function getPid (aRunner) {
	if (!!aRunner.childPid)
		return aRunner.childPid;

	if (!aRunner.opts.pidfile)
		return 0;
	try {
		return parseInt(fs.readFileSync(aRunner.opts.pidfile));
	} catch (e) {
		// ignore. Assume it is not running.
	}
	return 0;
};

/** Store the daemon's pid into the pidfile.
 *  @return 0 on success, the error code  otherwise. */
function savePid (pidfile, pid) {
	try {
		fs.writeFileSync(pidfile, pid + '\n');
	} catch (e) {
		return e.code;
	}
	return 0;
};

/** Send the given signal to the given pid. Does nothing, if pid == 0.
   @return the given pid on success, 0 otherwise. */
function sendSignal(pid, signal) {
	if (pid == 0)
		return 0;
	try {
		process.kill(pid, signal || 0);
		return pid;
	} catch (e) {
		// This may e.g. fail, if the proces has no proc_info privilege.
		// can't do anything about it.
	}
	return 0;
};

/** Get the pid of the daemon and send it a NOOP aka 0 signal.
	@return the pid of the running daemon on success, 0 otherwise. */
Runner.prototype.getStatus = function() {
	checkPidfileOption(this, false);
	return sendSignal(getPid(this), 0);
};

/** Create a temporary file (see mktemp(1)) and if deleteOnExit is given,
	schedule a callback to remove it on exit.
	@return the uniqe filename on success, null otherwise. */
function mktemp (aRunner, deleteOnExit) {
	if ((!!aRunner.opts.uid) && aRunner.opts.uid != process.geteuid())
		return null;
	var tmp = null;
	try {
		tmp = child_process.spawnSync('mktemp', [ '-t', 'daemon3.XXXXXX' ]);
		tmp = tmp.stdout.toString().trim();
		if (tmp && !!deleteOnExit) {
			process.once('exit', function() {
				try { fs.unlinkSync(tmp); } catch (e) { };
			});
		}
	} catch(e) {
		console.warn('Unable to create tmpfile (' + e.message + ').');
		tmp = null;
	}
	return tmp;
}

/** Create a socket incl. server listening on it as a fallback for the daemon
	aka process child to give feedback evene if the IPC channel already as been
	closed. Closing the IPC channel on the child side early is required, so 
	that it can exit immediately, when its work has been done or an error
	occured (for more information have a look at the end of the daemon.js).
	When the server gets a message, it tries to translate it into the same
	object it would have received via IPC otherwise, and emits a corresponding
	'daemon' event to let the runner's listeners catch up. */
function mkSocket (aRunner) {
	var tmp = mktemp(aRunner);
	if (!tmp)
		return null;

	var chunkHandler = function(chunk) {
		var data;
		try {
			data = JSON.parse(chunk.toString());
		} catch(e) {
			console.log(e);	// should not happen
			return;
		}
		notify(aRunner, data);
	};
	try {
		fs.unlinkSync(tmp);
		aRunner.server = net.createServer(function(socket) {
			socket.on('data', chunkHandler);
		});
		aRunner.server.listen(tmp, this);
		aRunner.server.unref();	// let the runner exit
		aRunner.opts.socket = tmp;
	} catch (e) {
		console.log(e);	// unlikely to happen
	}
}

/** Transform the given data into a standard 'daemon' event if possible, and
	let the given emitter broadcast it. */
function notify(emitter, data) {
	if (data == null || typeof data !== 'object'
		|| typeof data.info !== 'string' || !data.info.startsWith('daemon_'))
	{
		return;
	}
	var o = { info: data.info.substr(7), code: data.code||0, msg: data.msg||''};
	emitter.emit('daemon', o);
}

/** Check current options and try to start the given app as daemon.
	@return true on success (i.e. an instance is already running/has been
	started), false otherwise.
	@NOTE that a return value of true just means 'started'. Successfully or
	not will be determined depending on the feedback once the client
	sends it [or not]. If the client doesn't give a feedback within the timeout
	used in the runner's options, it is considered dead after timeout+1 second. */
Runner.prototype.startDaemon = function() {
	if (!!this.starting) {
		this.emit('daemon', { info: 'start_in_progress', code: 0 });
		return false;
	}
	Object.defineProperty(this, 'starting', {
		value: true,
		writable: false
	});
	var err = this.checkOptions();
	if (err.length > 0) {
		this.emit('daemon', { info: 'options_error', code: 1, errors: err });
		return false;
	}

    var pid = this.getStatus();
	if (pid) {
		this.emit('daemon', { info: 'already_running', code: 0, pid: pid });
		return true;
	}

	var args = (!this.opts.execArgv) ? [] : this.opts.execArgv.slice(0);
	args = args.concat(__dirname + "/daemon.js", this.opts.args);
	var options = { detached: !this.opts.foreground };
	for (var key of [ 'cwd', 'env', 'stdio', 'uid', 'gid' ]) {
		if (!!this.opts[key]) {
			options[key] = this.opts[key];
		}
	}
	this.timeoutHandlerId = setTimeout(function() {
        this.emit('daemon', { info: 'timeout', code: 0 }); // assume it is ok
    }.bind(this), this.opts.timeout * 1000 + 1000);

	// we need a real socket to communicate with the child
	var socket = mkSocket(this);
    this.emit('daemon', { info: 'starting', code: 0 });
	var c = null;
	try {
		c = child_process.spawn(process.execPath, args, options);
		// remove child from reference count to let this process exit
		if (!this.opts.foreground) c.unref();
	} catch (e) {
		this.emit('daemon', { info: 'spawn_failed', code: 1, msg: e.message });
		return false;
	}
	Object.defineProperty(this, 'child', {
		value: c,
		writable: false
	});
	Object.defineProperty(this, 'childPid', {
		value: c.pid,
		writable: false,
		eumerate: true
	});
	savePid(this.opts.pidfile, c.pid);

	// broadcast child messages
	c.on('message', function(data) { notify(this, data); }.bind(this));
	c.once('exit', function(exitCode) {
		this.emit('daemon', { info: 'exit', code: exitCode });
	}.bind(this));

	// prepared, so fire
	try {
		c.send({ cmd: "start_daemon", options: this.opts });
	} catch(e) {
		this.emit('daemon', { info: 'start_failed', code: 1, msg: e.message });
		return false;
	}
	return true;
};

/** Remove all runner/daemon related state information and handles, so that all
	changes made in this file aka runner, which would otherwise prevent the
	process' exit, get cleaned. */
function cleanup (aRunner) {
	// no exception should happen here. Therefore we log direct to console
	// if horses are puking ...
	if (!!aRunner.child) {
		if (!!aRunner.child.connected) {
			try { aRunner.child.disconnect(); } catch(e) { console.log(e); }
		}
		try { delete aRunner.child; } catch(e) { };
		try { delete aRunner.childPid; } catch(e) { };
	}
	try { delete aRunner.starting; } catch(e) { };
	if (!!aRunner.timeoutHandlerId) {
		clearTimeout(aRunner.timeoutHandlerId);
	}
	try { delete aRunner.timeoutHandlerId; } catch(e) { };
	if (!!aRunner.server) {
		try {
			aRunner.server.close();
			delete aRunner.server;
		} catch(e) {
			console.log(e);
		}
	}
}

/** Try to stop the already daemonized app. if possible. If the given pidfile
	is different than the one, which was used when the app got started or the
	pidfile is not readable anymore/contains garbage or this process is not
	allowed to send a signal to the running app, this call will fail. Otherwise
	a job gets scheduled, which removes the pidfile as soon as the daemon does
	not respond to keep alive messages (kill -0).
	@return true on success, false otherwise. */
Runner.prototype.stop = function() {
	var pid = this.getStatus();
	if (pid == 0) {
		this.emit('daemon', { info: 'no_pid', code: 1 });
		return false;
	}
	if (sendSignal(pid, 'SIGTERM') == 0) {
		emit('daemon', { info: 'stop_failed', code: 1 });
		return false;
	}
	var tId = setInterval(function(){
		if (this.getStatus() == 0) {
			if (!!this.opts.pidfile)
				try { fs.unlinkSync(runner.opts.pidfile); } catch (e) { };
			this.emit('daemon', { info: 'stopped', code: 0 });
			clearInterval(tId);
		}
	}.bind(this), 100);
	return true;
};

/** The default listener used to reflect client feedback on the console,
	sets the exit code of this process accordingly and cleans up all runner
	related stuff, which would prevent this process from exiting if necessary.*/
Runner.prototype.defaultListener = function(data) {
	var doCleanup = true;
	switch (data.info) {
		// start
		case 'start_in_progress':
			console.warn('Another daemon start is already in progress.');
			doCleanup = false;
			break;
		case 'options_error':
			console.error('The following problems have been found: '
				+ data.errors.join('\n'));
			break;
		case 'already_running':
			console.info('The daemon with the pid ' + data.pid
				+ ' seems to be already running.');
			break;
		case 'starting':
			console.info('Starting ' + this.opts.name + ' ...');
			doCleanup = false;
			break;
		case 'spawn_failed':
			console.error('Failed (' + data.msg + ').');
			break;
		case 'timeout':
			this.timeoutHandlerId = null;
			console.warn('Timeout reached - client state unknown');
			break;
		case 'ok': //child messages
			console.info(data.code == 0
				? 'Done (' + data.msg + ').'
				: 'Failed (exit code ' + data.code + ').');
			break;
		case 'sw_error':
			console.warn('SoftwareError: ' + data.msg);
			doCleanup = false;
			break;
		case 'exit':
			console.error('Failed (terminated unexpectedly with exit code '
				+ data.code + ').');
			break;
		case 'start_failed':
			console.error('Failed (' + data.msg + ').');
			break;
		// stop
		case 'no_pid':
			console.error('Unable to stop daemon - PID not found.');
			doCleanup = false;
			break;
		case 'stop_failed':
			console.error('Unable to signal TERM to daemon.');
			doCleanup = false;
			break;
		case 'stopped':
			console.info(this.opts.name + ' stopped.');
			doCleanup = false;
			break;
	}
	if (!!data.code)
		process.exitCode = data.code;
	if (doCleanup)
		cleanup(this);
}
